<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>Technical Overview
</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="description" content="A general-purpose serialization library for .NET"/>
    <meta name="author" content="Eirik Tsarpalis"/>

    <script src="https://code.jquery.com/jquery-1.8.0.js"></script>
    <script src="https://code.jquery.com/ui/1.8.23/jquery-ui.js"></script>
    <script src="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/js/bootstrap.min.js"></script>
    <link href="https://netdna.bootstrapcdn.com/twitter-bootstrap/2.2.1/css/bootstrap-combined.min.css" rel="stylesheet"/>

    <link type="text/css" rel="stylesheet" href="/FsPickler/content/style.css" />
    <script type="text/javascript" src="/FsPickler/content/tips.js"></script>
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="https://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container">
      <div class="masthead">
        <ul class="nav nav-pills pull-right">
          <li><a href="http://mbrace.io/">mbrace</a></li>
          <li><a href="http://github.com/mbraceproject/FsPickler">github page</a></li>
        </ul>
        <h3 class="muted"><a href="/FsPickler/index.html">FsPickler</a></h3>
      </div>
      <hr />
      <div class="row">
        <div class="span9" id="main">
          <h1><a name="Technical-Overview" class="anchor" href="#Technical-Overview">Technical Overview</a></h1>
<p>This article discusses the general topic of serialization in .NET
and gives an overview of the implementation details in FsPickler.</p>
<h2><a name="Serialization-in-the-NET-framework" class="anchor" href="#Serialization-in-the-NET-framework">Serialization in the .NET framework</a></h2>
<p>Serialization in the .NET framework is something often considered
as being problematic or even broken. This could be tracked to the following reasons:</p>
<ul>
<li>
<p>There is no runtime or type system support for serialization.
Rather, serializers are library implementations that mostly depend
on the reflection system to extrapolate serialization rules for
each type (resulting in runtime errors if this is not possible).</p>
</li>
<li>
<p>There is confusion as to which is the prefered methodology when
defining serialization semantics for types.
The BCL itself comes with a multitude of approaches most of which are
dated, unsafe and inefficient by design.</p>
</li>
</ul>
<h3><a name="BCL-Serialization-methods" class="anchor" href="#BCL-Serialization-methods">BCL Serialization methods</a></h3>
<p>The BCL comes with the following patterns for defining serializable types:</p>
<ul>
<li>
<p>Field-based serialization: objects are pickled by serializing the contents
of their fields. This behaviour is tuned by applying an assortment of attributes such as
<a href="http://msdn.microsoft.com/en-us/library/system.nonserializedattribute.aspx"><code>NonSerialized</code></a>,
<a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.onserializingattribute.aspx"><code>OnSerializing</code></a>,
<a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.ondeserializedattribute.aspx"><code>OnDeserialized</code></a>
and the <a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.ideserializationcallback.aspx"><code>IDeserializationCallback</code></a>
interface. This is arguably the most problematic approach, since it is sensitive to internal implementation details.
Incidentally, this is the pattern of choice for most F# types.</p>
</li>
<li>
<p>Property-based or <a href="http://msdn.microsoft.com/en-us/library/ms733127.aspx">DataContract</a>
serialization: objects are pickled by serializing the contents
of specially flagged properties. Properties should be settable and are usually required to be
public. In most cases, a parameterless constructor is also necessary. Property-based serialization
is probably the most popular approach.</p>
</li>
<li>
<p><a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.iserializable.aspx">ISerializable</a>
types: possibly intended as a type-safe replacement of field-based serialization.
It fails to live up to this role, mostly due to the nature of interfaces; it still requires a
special constructor for deserialization which, if missing, would result in a runtime error.
It requires separate implementations for serialization and deserialization, often leading to bugs
and introducing lots of boilerplate code.
Its dynamic nature also makes it impossible to reason about the components it serializes a priori.
It is however an indispensible pattern since it is used by many BCL types, most important being
exceptions, whose metadata is impossible to serialize otherwise.</p>
</li>
</ul>
<h3><a name="Serialization-Libraries" class="anchor" href="#Serialization-Libraries">Serialization Libraries</a></h3>
<p>The BCL ships with a couple of general-purpose serializer libraries but these suffer either
from obsolescence (e.g. <a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter.aspx">BinaryFormatter</a>)
or performance (<a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.netdatacontractserializer.aspx">NetDataContractSerializer</a>).
Many third-party libraries have emerged attempting to address these shortcomings,
some with success. However, most of them seem to suffer when it comes to properly
supporting serialization of .NET objects. In particular many of them:</p>
<ul>
<li><p>offer sketchy or no support for reflection types, like <code>MemberInfo</code>.</p></li>
<li>require library-specific dependencies for serializable type definitions.</li>
<li>do not support inaccessible types/constructors/properties.</li>
<li>fail to address subtype polymorphism.</li>
<li>do not support types like multi-dimensional arrays or delegates.</li>
<li>fail to properly handle cyclic objects.</li>
<li>have limited or nonexistent support for F# types.</li>
</ul>
<h2><a name="FsPickler-Motivation" class="anchor" href="#FsPickler-Motivation">FsPickler : Motivation</a></h2>
<p>The need for a new serialization library was realized while developing for
<a href="http://mbrace.io/">MBrace</a>. MBrace is a framework for distributed
computation and big data that is essentially built on the idea of a distributed
continuation monad. To be able to distribute continuations, you need to be able to
serialize closures. The inherently intrinsic and arbitrary nature of closures means
that they are not supported by most serialization libraries.
Initially we started using NetDataContractSerializer as our library of choice,
but that eventually took its toll on overall performance,
so we decided to build a new library from scratch.</p>
<p>FsPickler was created with two goals in mind: performance and completeness in supported objects.
Importantly, it was conceived as a .NET serializer, rather than an F# serializer:
if it is a .NET object designed to be serialized, it should be serializable in FsPickler.
In that sense, it was designed with a goal to embrace the imperfect world of
.NET serialization in its totality, albeit with an eye for correctness.</p>
<p>At this point, we should acknowledge Anton Tayanovskyy and his great F#
snippet <a href="http://www.fssnip.net/6u">Union-Friendly Generic Binary Serializer</a>
which served as the initial inspiration for this library.</p>
<h2><a name="Pickler-Combinators" class="anchor" href="#Pickler-Combinators">Pickler Combinators</a></h2>
<p>FsPickler is founded on the functional programming notion of picklers and pickler combinators.
The concept was originally described in Andrew Kennedy's
<a href="http://research.microsoft.com/pubs/64036/picklercombinators.pdf">Pickler Combinators</a>.
A pickler is essentially the type:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, 'fs6', 8)" onmouseover="showTip(event, 'fs6', 8)" class="rt">Pickler</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span class="pn">{</span>
        <span onmouseout="hideTip(event, 'fs7', 9)" onmouseover="showTip(event, 'fs7', 9)" class="fn">Write</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs8', 10)" onmouseover="showTip(event, 'fs8', 10)" class="rt">WriteState</span> <span class="k">-&gt;</span> <span class="ta">&#39;</span><span class="id">T</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs9', 11)" onmouseover="showTip(event, 'fs9', 11)" class="rt">unit</span>
        <span onmouseout="hideTip(event, 'fs10', 12)" onmouseover="showTip(event, 'fs10', 12)" class="fn">Read</span>  <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs11', 13)" onmouseover="showTip(event, 'fs11', 13)" class="rt">ReadState</span>  <span class="k">-&gt;</span> <span class="ta">&#39;</span><span class="id">T</span>
    <span class="pn">}</span>
</code></pre></td>
</tr>
</table>
<p>The <code>Write</code> and <code>Read</code> functions represent serialization and deserialization
implementations for values of type <code>'T</code>. When compared to other .NET serializers,
picklers prove exceptionally fast since they directly handle the serialized value
without any reliance on reflection-based resolution.</p>
<p>Pickler combinators are functions that operate on picklers, generating picklers of more complex types.
For instance, the following could be a pickler combinator implementation for rank-1 arrays:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
<span class="l">4: </span>
<span class="l">5: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs12', 14)" onmouseover="showTip(event, 'fs12', 14)" class="fn">mkArrayPickler</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs13', 15)" onmouseover="showTip(event, 'fs13', 15)" class="id">ip</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs6', 16)" onmouseover="showTip(event, 'fs6', 16)" class="rt">Pickler</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs14', 17)" onmouseover="showTip(event, 'fs14', 17)" class="vt">int</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs15', 18)" onmouseover="showTip(event, 'fs15', 18)" class="id">tp</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs6', 19)" onmouseover="showTip(event, 'fs6', 19)" class="rt">Pickler</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs6', 20)" onmouseover="showTip(event, 'fs6', 20)" class="rt">Pickler</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span> <span class="pn">[</span><span class="pn">]</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span class="pn">{</span>
        <span class="fn">Write</span> <span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs16', 21)" onmouseover="showTip(event, 'fs16', 21)" class="id">s</span> <span onmouseout="hideTip(event, 'fs17', 22)" onmouseover="showTip(event, 'fs17', 22)" class="id">a</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs13', 23)" onmouseover="showTip(event, 'fs13', 23)" class="fn">ip</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 24)" onmouseover="showTip(event, 'fs18', 24)" class="id">Write</span> <span onmouseout="hideTip(event, 'fs16', 25)" onmouseover="showTip(event, 'fs16', 25)" class="id">s</span> <span onmouseout="hideTip(event, 'fs17', 26)" onmouseover="showTip(event, 'fs17', 26)" class="id">a</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 27)" onmouseover="showTip(event, 'fs18', 27)" class="id">Length</span> <span class="pn">;</span> <span onmouseout="hideTip(event, 'fs19', 28)" onmouseover="showTip(event, 'fs19', 28)" class="m">Array</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs20', 29)" onmouseover="showTip(event, 'fs20', 29)" class="id">iter</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs15', 30)" onmouseover="showTip(event, 'fs15', 30)" class="fn">tp</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 31)" onmouseover="showTip(event, 'fs18', 31)" class="id">Write</span> <span onmouseout="hideTip(event, 'fs16', 32)" onmouseover="showTip(event, 'fs16', 32)" class="id">s</span><span class="pn">)</span> <span onmouseout="hideTip(event, 'fs17', 33)" onmouseover="showTip(event, 'fs17', 33)" class="id">a</span>
        <span class="fn">Read</span> <span class="o">=</span> <span class="k">fun</span> <span onmouseout="hideTip(event, 'fs21', 34)" onmouseover="showTip(event, 'fs21', 34)" class="id">s</span> <span class="k">-&gt;</span> <span class="k">let</span> <span onmouseout="hideTip(event, 'fs22', 35)" onmouseover="showTip(event, 'fs22', 35)" class="id">l</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs13', 36)" onmouseover="showTip(event, 'fs13', 36)" class="fn">ip</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 37)" onmouseover="showTip(event, 'fs18', 37)" class="id">Read</span> <span onmouseout="hideTip(event, 'fs21', 38)" onmouseover="showTip(event, 'fs21', 38)" class="id">s</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fs19', 39)" onmouseover="showTip(event, 'fs19', 39)" class="m">Array</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs23', 40)" onmouseover="showTip(event, 'fs23', 40)" class="id">init</span> <span onmouseout="hideTip(event, 'fs22', 41)" onmouseover="showTip(event, 'fs22', 41)" class="id">l</span> <span class="pn">(</span><span class="k">fun</span> <span class="id">_</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, 'fs15', 42)" onmouseover="showTip(event, 'fs15', 42)" class="fn">tp</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 43)" onmouseover="showTip(event, 'fs18', 43)" class="id">Read</span> <span onmouseout="hideTip(event, 'fs21', 44)" onmouseover="showTip(event, 'fs21', 44)" class="id">s</span><span class="pn">)</span>
    <span class="pn">}</span>
</code></pre></td>
</tr>
</table>
<p>Given a sufficient range of primitive picklers and pickler combinators,
it is possible to define pickling rules for most essentially serializable .NET types.
However, these would still need to be declared manually by their implementor.</p>
<p>FsPickler attempts to solve this by providing an automated pickler generation framework:
picklers are generated at runtime and on demand using a combination of reflection and
dynamic IL generation. Picklers are cached for future use, hence the cost of generation
has a constant price.</p>
<p>Moreover, it extends the concept of picklers so that features particular to the
.NET framework are accommodated: object orientation and subtype polymorphism,
null references and cyclic objects.</p>
<p>It should be mentioned for the sake of completeness that a
<a href="http://lampwww.epfl.ch/~hmiller/files/pickling.pdf">similar effort</a>
has been undertaken by the Scala community. There are differences of approach however,
since this mostly relies on the metaprogramming facility offered by scala.</p>
<h2><a name="Serializable-Types" class="anchor" href="#Serializable-Types">Serializable Types</a></h2>
<p>So what qualifies as a serializable type in FsPickler?
The short answer would be any type <code>'T</code> for which we present an instance of
<a href="reference/mbrace-fspickler-pickler-1.html"><code>Pickler&lt;'T&gt;</code></a>.
To make the question more meaningful: for what types does the library auto-generate picklers?
This is something that can only be answered at runtime, typically by calling</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span onmouseout="hideTip(event, 'fs24', 47)" onmouseover="showTip(event, 'fs24', 47)" class="rt">FsPickler</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs25', 48)" onmouseover="showTip(event, 'fs25', 48)" class="id">IsSerializableType</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs5', 49)" onmouseover="showTip(event, 'fs5', 49)" class="rt">SomeType</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>
</code></pre></td>
</tr>
</table>
<p>Primitive types and <code>string</code> are serializable but pointers, COM objects and MarshalByRef types are not.
A managed class or struct is serializable if and only if it carries the <code>Serializable</code> flag or attribute
and moreover satisfies either of the following:</p>
<ul>
<li>is array/nullable/tuple/enum of serializable element types.</li>
<li><p>implements the <code>ISerializable</code> interface and has a matching constructor implementation.</p></li>
<li>
<p>carries the <code>DataContract</code> attribute and all <code>DataMember</code> members are of serializable type.
Properties carrying the <code>DataMember</code> attribute must be settable.
Parameterless constructors or public properties are not required.</p>
</li>
<li>is an F# union or record type in which all contained fields are serializable.</li>
<li><p>carries the <a href="reference/mbrace-fspickler-custompicklerattribute.html"><code>CustomPickler</code></a> attribute and an accompanying pickler factory method.</p></li>
<li>
<p>is neither of the above and all its contained fields are of serializable type.
Parameterless constructors or public fields are not required.</p>
</li>
</ul>
<h2><a name="Object-Oriented-Picklers" class="anchor" href="#Object-Oriented-Picklers">Object Oriented Picklers</a></h2>
<p>We now discuss how the functional programming concept of picklers can be
reconciled with the object-oriented .NET framework.
It is useful to note here that reference type serialization essentially
means object graph serialization.
Object graphs in .NET can often contain null references or cycles,
which ought to be fully supported.
FsPickler automatically augments reference types so that such
occurences are handled effectively.</p>
<p>Object graphs are serialized by performing depth-first traversal;
this approach improves performance by eliminating unnecessary
boxings in object queues but is sensitive to stack overflow conditions.
FsPickler uses
<a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.objectidgenerator.aspx"><code>ObjectIdGenerator</code></a>
for keeping track of traversed references and detecting cycles.
Cyclic objects are re-instantiated lazily through shallow field copying.</p>
<h3><a name="Subtyping" class="anchor" href="#Subtyping">Subtyping</a></h3>
<p>FsPickler discriminates between reference types that are sealed and those that are not sealed.
A value of non-sealed type can either be instance of this type or of a proper subtype.
In the context of open hierarchies, it is clear that a type-fixed pickler implementation simply
cannot cater to arbitrary subtype instances.</p>
<p>For this reason, picklers will only be used to serialize values whose reflected type is identical
to the pickler's. When coming across an object of non-sealed type, FsPickler
will examine its reflected type; if found to differ, a new pickler will be
generated on-the-fly for that particular subtype.</p>
<p>The above implies that <code>obj</code> is serializable in FsPickler, but <code>Pickler&lt;obj&gt;</code>
will only be used with <code>obj()</code> instances. Similarly, picklers for interfaces
or abstract classes are possible, but on their own are incapable of serializing anything.
This is how serialization of F# closures is made possible:
for every internal closure type generated by the F# compiler,
a special pickler is generated for handling it.</p>
<h2><a name="Pickler-Generation" class="anchor" href="#Pickler-Generation">Pickler Generation</a></h2>
<p>Conceptually, pickler implementations found in the library can roughly be separated into
the following categories:</p>
<ul>
<li>
<p>Atomic picklers: self containing pickler implementations for types like primitives,
strings, <code>System.DateTime</code> and <code>System.Guid</code>. These do little other than delegating
serialization to the underlying
<a href="reference/mbrace-fspickler-ipickleformatprovider.html">pickle format</a>
implementation.</p>
</li>
<li>
<p>Pickler combinators: as described earlier, these are parametric functions generating picklers
out of simpler components. Examples are option, list, array and tuple picklers.</p>
</li>
<li>
<p>Pickler generators: for nominal types that are not expressions on known types,
a different generation strategy is required. The type structure is determined using reflection
and a new pickler is constructed from that information. FsPickler can emit dynamic methods
to ensure that no reflection or boxing penalty is incurred during actual serialization.
Pickler generators can be further separated into the following kinds:</p>
<ul>
<li>Field-based pickler generation.</li>
<li>DataContract pickler generation.</li>
<li>ISerializable pickler generation.</li>
<li>F# union/record/exception pickler generation.</li>
</ul>
</li>
</ul>
<h3><a name="Putting-it-all-together" class="anchor" href="#Putting-it-all-together">Putting it all together</a></h3>
<p>So how does FsPickler generate a pickler (or fail trying) for a given type parameter?
I will attempt to explain by giving a simplified example:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
<span class="l">21: </span>
<span class="l">22: </span>
<span class="l">23: </span>
<span class="l">24: </span>
<span class="l">25: </span>
<span class="l">26: </span>
<span class="l">27: </span>
<span class="l">28: </span>
<span class="l">29: </span>
<span class="l">30: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="pn">[&lt;</span><span onmouseout="hideTip(event, 'fs26', 50)" onmouseover="showTip(event, 'fs26', 50)" class="rt">AbstractClass</span><span class="pn">&gt;]</span>
<span class="k">type</span> <span onmouseout="hideTip(event, 'fs27', 51)" onmouseover="showTip(event, 'fs27', 51)" class="rt">TypeShape</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">abstract</span> <span class="fn">Accept</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs28', 52)" onmouseover="showTip(event, 'fs28', 52)" class="if">ITypeShapeVisitor</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">R</span><span class="pn">&gt;</span> <span class="k">-&gt;</span> <span class="ta">&#39;</span><span class="id">R</span>

<span class="k">and</span> <span onmouseout="hideTip(event, 'fs29', 53)" onmouseover="showTip(event, 'fs29', 53)" class="rt">ShapeInt</span> <span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">inherit</span> <span onmouseout="hideTip(event, 'fs27', 54)" onmouseover="showTip(event, 'fs27', 54)" class="rt">TypeShape</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs14', 55)" onmouseover="showTip(event, 'fs14', 55)" class="vt">int</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>
    <span class="k">override</span> <span class="id">__</span><span class="pn">.</span><span class="fn">Accept</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs30', 56)" onmouseover="showTip(event, 'fs30', 56)" class="id">v</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs28', 57)" onmouseover="showTip(event, 'fs28', 57)" class="if">ITypeShapeVisitor</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">R</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs30', 58)" onmouseover="showTip(event, 'fs30', 58)" class="fn">v</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 59)" onmouseover="showTip(event, 'fs18', 59)" class="id">VisitInt</span> <span class="pn">(</span><span class="pn">)</span>

<span class="k">and</span> <span onmouseout="hideTip(event, 'fs31', 60)" onmouseover="showTip(event, 'fs31', 60)" class="rt">ShapeString</span> <span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">inherit</span> <span onmouseout="hideTip(event, 'fs27', 61)" onmouseover="showTip(event, 'fs27', 61)" class="rt">TypeShape</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs32', 62)" onmouseover="showTip(event, 'fs32', 62)" class="rt">string</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>
    <span class="k">override</span> <span class="id">__</span><span class="pn">.</span><span class="fn">Accept</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs33', 63)" onmouseover="showTip(event, 'fs33', 63)" class="id">v</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs28', 64)" onmouseover="showTip(event, 'fs28', 64)" class="if">ITypeShapeVisitor</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">R</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs33', 65)" onmouseover="showTip(event, 'fs33', 65)" class="fn">v</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 66)" onmouseover="showTip(event, 'fs18', 66)" class="id">VisitString</span> <span class="pn">(</span><span class="pn">)</span>

<span class="k">and</span> <span onmouseout="hideTip(event, 'fs34', 67)" onmouseover="showTip(event, 'fs34', 67)" class="rt">ShapeTuple</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">inherit</span> <span onmouseout="hideTip(event, 'fs27', 68)" onmouseover="showTip(event, 'fs27', 68)" class="rt">TypeShape</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span> <span class="pn">*</span> <span class="ta">&#39;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>
    <span class="k">override</span> <span class="id">__</span><span class="pn">.</span><span class="fn">Accept</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs35', 69)" onmouseover="showTip(event, 'fs35', 69)" class="id">v</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs28', 70)" onmouseover="showTip(event, 'fs28', 70)" class="if">ITypeShapeVisitor</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">R</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs35', 71)" onmouseover="showTip(event, 'fs35', 71)" class="fn">v</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 72)" onmouseover="showTip(event, 'fs18', 72)" class="id">VisitTuple</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>

<span class="k">and</span> <span onmouseout="hideTip(event, 'fs36', 73)" onmouseover="showTip(event, 'fs36', 73)" class="rt">ShapeList</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">inherit</span> <span onmouseout="hideTip(event, 'fs27', 74)" onmouseover="showTip(event, 'fs27', 74)" class="rt">TypeShape</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span> <span onmouseout="hideTip(event, 'fs37', 75)" onmouseover="showTip(event, 'fs37', 75)" class="rt">list</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>
    <span class="k">override</span> <span class="id">__</span><span class="pn">.</span><span class="fn">Accept</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs38', 76)" onmouseover="showTip(event, 'fs38', 76)" class="id">v</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs28', 77)" onmouseover="showTip(event, 'fs28', 77)" class="if">ITypeShapeVisitor</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">R</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs38', 78)" onmouseover="showTip(event, 'fs38', 78)" class="fn">v</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 79)" onmouseover="showTip(event, 'fs18', 79)" class="id">VisitList</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>

<span class="k">and</span> <span onmouseout="hideTip(event, 'fs39', 80)" onmouseover="showTip(event, 'fs39', 80)" class="rt">ShapeSet</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span> <span class="k">when</span> <span class="ta">&#39;</span><span class="id">T</span> <span class="pn">:</span> <span class="id">comparison</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
    <span class="k">inherit</span> <span onmouseout="hideTip(event, 'fs27', 81)" onmouseover="showTip(event, 'fs27', 81)" class="rt">TypeShape</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs40', 82)" onmouseover="showTip(event, 'fs40', 82)" class="rt">Set</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>
    <span class="k">override</span> <span class="id">__</span><span class="pn">.</span><span class="fn">Accept</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs41', 83)" onmouseover="showTip(event, 'fs41', 83)" class="id">v</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs28', 84)" onmouseover="showTip(event, 'fs28', 84)" class="if">ITypeShapeVisitor</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">R</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs41', 85)" onmouseover="showTip(event, 'fs41', 85)" class="fn">v</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 86)" onmouseover="showTip(event, 'fs18', 86)" class="id">VisitSet</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>

<span class="k">and</span> <span onmouseout="hideTip(event, 'fs28', 87)" onmouseover="showTip(event, 'fs28', 87)" class="if">ITypeShapeVisitor</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">R</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span class="k">abstract</span> <span class="fn">VisitInt</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs9', 88)" onmouseover="showTip(event, 'fs9', 88)" class="rt">unit</span> <span class="k">-&gt;</span> <span class="ta">&#39;</span><span class="id">R</span>
    <span class="k">abstract</span> <span class="fn">VisitString</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs9', 89)" onmouseover="showTip(event, 'fs9', 89)" class="rt">unit</span> <span class="k">-&gt;</span> <span class="ta">&#39;</span><span class="id">R</span>
    <span class="k">abstract</span> <span class="fn">VisitTuple</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs9', 90)" onmouseover="showTip(event, 'fs9', 90)" class="rt">unit</span> <span class="k">-&gt;</span> <span class="ta">&#39;</span><span class="id">R</span>
    <span class="k">abstract</span> <span class="fn">VisitList</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs9', 91)" onmouseover="showTip(event, 'fs9', 91)" class="rt">unit</span> <span class="k">-&gt;</span> <span class="ta">&#39;</span><span class="id">R</span>
    <span class="k">abstract</span> <span class="fn">VisitSet</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span> <span class="k">when</span> <span class="ta">&#39;</span><span class="id">T</span> <span class="pn">:</span> <span class="id">comparison</span><span class="pn">&gt;</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs9', 92)" onmouseover="showTip(event, 'fs9', 92)" class="rt">unit</span> <span class="k">-&gt;</span> <span class="ta">&#39;</span><span class="id">R</span>
</code></pre></td>
</tr>
</table>
<p>The above declarations define a notion of "type shape", a partitioning of types according
to certain traits satisfied. This pattern gives naturally rise to a "type shape visitor",
which we will be making use of later. Given an arbitrary type <code>'T</code>, we can use reflection to extract
and construct the shape it fits in, albeit in a packaged manner:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs42', 93)" onmouseover="showTip(event, 'fs42', 93)" class="id">getShape</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span class="k">if</span> <span onmouseout="hideTip(event, 'fs43', 94)" onmouseover="showTip(event, 'fs43', 94)" class="k">typeof</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs43', 95)" onmouseover="showTip(event, 'fs43', 95)" class="k">typeof</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs14', 96)" onmouseover="showTip(event, 'fs14', 96)" class="vt">int</span><span class="pn">&gt;</span> <span class="k">then</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fs29', 97)" onmouseover="showTip(event, 'fs29', 97)" class="rt">ShapeInt</span><span class="pn">(</span><span class="pn">)</span> <span class="o">:&gt;</span> <span onmouseout="hideTip(event, 'fs44', 98)" onmouseover="showTip(event, 'fs44', 98)" class="rt">obj</span> <span class="o">:?&gt;</span> <span onmouseout="hideTip(event, 'fs27', 99)" onmouseover="showTip(event, 'fs27', 99)" class="rt">TypeShape</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span>
    <span class="k">elif</span> <span onmouseout="hideTip(event, 'fs43', 100)" onmouseover="showTip(event, 'fs43', 100)" class="k">typeof</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs43', 101)" onmouseover="showTip(event, 'fs43', 101)" class="k">typeof</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs32', 102)" onmouseover="showTip(event, 'fs32', 102)" class="rt">string</span><span class="pn">&gt;</span> <span class="k">then</span> <span class="k">new</span> <span onmouseout="hideTip(event, 'fs31', 103)" onmouseover="showTip(event, 'fs31', 103)" class="rt">ShapeString</span><span class="pn">(</span><span class="pn">)</span> <span class="o">:&gt;</span> <span onmouseout="hideTip(event, 'fs44', 104)" onmouseover="showTip(event, 'fs44', 104)" class="rt">obj</span> <span class="o">:?&gt;</span> <span onmouseout="hideTip(event, 'fs27', 105)" onmouseover="showTip(event, 'fs27', 105)" class="rt">TypeShape</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span>
    <span class="k">elif</span> <span onmouseout="hideTip(event, 'fs43', 106)" onmouseover="showTip(event, 'fs43', 106)" class="k">typeof</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span><span class="pn">.</span><span class="id">IsGenericType</span> <span class="k">then</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs45', 107)" onmouseover="showTip(event, 'fs45', 107)" class="id">gt</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs43', 108)" onmouseover="showTip(event, 'fs43', 108)" class="k">typeof</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span><span class="pn">.</span><span class="id">GetGenericTypeDefinition</span><span class="pn">(</span><span class="pn">)</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, 'fs46', 109)" onmouseover="showTip(event, 'fs46', 109)" class="id">tparams</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs43', 110)" onmouseover="showTip(event, 'fs43', 110)" class="k">typeof</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span><span class="pn">.</span><span class="id">GetGenericArguments</span><span class="pn">(</span><span class="pn">)</span>
        <span class="k">if</span> <span onmouseout="hideTip(event, 'fs45', 111)" onmouseover="showTip(event, 'fs45', 111)" class="id">gt</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs47', 112)" onmouseover="showTip(event, 'fs47', 112)" class="k">typedefof</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs37', 113)" onmouseover="showTip(event, 'fs37', 113)" class="rt">list</span><span class="pn">&lt;</span><span class="id">_</span><span class="pn">&gt;</span><span class="pn">&gt;</span> <span class="k">then</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, 'fs48', 114)" onmouseover="showTip(event, 'fs48', 114)" class="id">st</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs47', 115)" onmouseover="showTip(event, 'fs47', 115)" class="k">typedefof</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs36', 116)" onmouseover="showTip(event, 'fs36', 116)" class="rt">ShapeList</span><span class="pn">&lt;</span><span class="id">_</span><span class="pn">&gt;</span><span class="pn">&gt;</span><span class="pn">.</span><span class="id">MakeGenericType</span> <span onmouseout="hideTip(event, 'fs46', 117)" onmouseover="showTip(event, 'fs46', 117)" class="id">tparams</span>
            <span onmouseout="hideTip(event, 'fs49', 118)" onmouseover="showTip(event, 'fs49', 118)" class="rt">Activator</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs50', 119)" onmouseover="showTip(event, 'fs50', 119)" class="id">CreateInstance</span> <span onmouseout="hideTip(event, 'fs48', 120)" onmouseover="showTip(event, 'fs48', 120)" class="id">st</span> <span class="o">:?&gt;</span> <span onmouseout="hideTip(event, 'fs27', 121)" onmouseover="showTip(event, 'fs27', 121)" class="rt">TypeShape</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span>
        <span class="k">elif</span> <span onmouseout="hideTip(event, 'fs45', 122)" onmouseover="showTip(event, 'fs45', 122)" class="id">gt</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs47', 123)" onmouseover="showTip(event, 'fs47', 123)" class="k">typedefof</span><span class="pn">&lt;</span><span class="id">_</span> <span class="pn">*</span> <span class="id">_</span><span class="pn">&gt;</span> <span class="k">then</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, 'fs48', 124)" onmouseover="showTip(event, 'fs48', 124)" class="id">st</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs47', 125)" onmouseover="showTip(event, 'fs47', 125)" class="k">typedefof</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs34', 126)" onmouseover="showTip(event, 'fs34', 126)" class="rt">ShapeTuple</span><span class="pn">&lt;</span><span class="id">_</span><span class="pn">,</span><span class="id">_</span><span class="pn">&gt;</span><span class="pn">&gt;</span><span class="pn">.</span><span class="id">MakeGenericType</span> <span onmouseout="hideTip(event, 'fs46', 127)" onmouseover="showTip(event, 'fs46', 127)" class="id">tparams</span>
            <span onmouseout="hideTip(event, 'fs49', 128)" onmouseover="showTip(event, 'fs49', 128)" class="rt">Activator</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs50', 129)" onmouseover="showTip(event, 'fs50', 129)" class="id">CreateInstance</span> <span onmouseout="hideTip(event, 'fs48', 130)" onmouseover="showTip(event, 'fs48', 130)" class="id">st</span> <span class="o">:?&gt;</span> <span onmouseout="hideTip(event, 'fs27', 131)" onmouseover="showTip(event, 'fs27', 131)" class="rt">TypeShape</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span>
        <span class="k">elif</span> <span onmouseout="hideTip(event, 'fs45', 132)" onmouseover="showTip(event, 'fs45', 132)" class="id">gt</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs47', 133)" onmouseover="showTip(event, 'fs47', 133)" class="k">typedefof</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs40', 134)" onmouseover="showTip(event, 'fs40', 134)" class="rt">Set</span><span class="pn">&lt;</span><span class="id">_</span><span class="pn">&gt;</span><span class="pn">&gt;</span> <span class="k">then</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, 'fs48', 135)" onmouseover="showTip(event, 'fs48', 135)" class="id">st</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs47', 136)" onmouseover="showTip(event, 'fs47', 136)" class="k">typedefof</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs39', 137)" onmouseover="showTip(event, 'fs39', 137)" class="rt">ShapeSet</span><span class="pn">&lt;</span><span class="id">_</span><span class="pn">&gt;</span><span class="pn">&gt;</span><span class="pn">.</span><span class="id">MakeGenericType</span> <span onmouseout="hideTip(event, 'fs46', 138)" onmouseover="showTip(event, 'fs46', 138)" class="id">tparams</span>
            <span onmouseout="hideTip(event, 'fs49', 139)" onmouseover="showTip(event, 'fs49', 139)" class="rt">Activator</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs50', 140)" onmouseover="showTip(event, 'fs50', 140)" class="id">CreateInstance</span> <span onmouseout="hideTip(event, 'fs48', 141)" onmouseover="showTip(event, 'fs48', 141)" class="id">st</span> <span class="o">:?&gt;</span> <span onmouseout="hideTip(event, 'fs27', 142)" onmouseover="showTip(event, 'fs27', 142)" class="rt">TypeShape</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span>
        <span class="k">else</span>
            <span onmouseout="hideTip(event, 'fs51', 143)" onmouseover="showTip(event, 'fs51', 143)" class="fn">failwith</span> <span class="s">&quot;unsupported type shape.&quot;</span>
    <span class="k">else</span>
        <span onmouseout="hideTip(event, 'fs51', 144)" onmouseover="showTip(event, 'fs51', 144)" class="fn">failwith</span> <span class="s">&quot;unsupported type shape.&quot;</span>
</code></pre></td>
</tr>
</table>
<p>We can now use the type shape visitor to plug in all required pickler combinators.
This will result in a generator function that recursively calls appropriate
pickler combinators in a strongly typed manner:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l"> 1: </span>
<span class="l"> 2: </span>
<span class="l"> 3: </span>
<span class="l"> 4: </span>
<span class="l"> 5: </span>
<span class="l"> 6: </span>
<span class="l"> 7: </span>
<span class="l"> 8: </span>
<span class="l"> 9: </span>
<span class="l">10: </span>
<span class="l">11: </span>
<span class="l">12: </span>
<span class="l">13: </span>
<span class="l">14: </span>
<span class="l">15: </span>
<span class="l">16: </span>
<span class="l">17: </span>
<span class="l">18: </span>
<span class="l">19: </span>
<span class="l">20: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, 'fs52', 145)" onmouseover="showTip(event, 'fs52', 145)" class="fn">generate</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs53', 146)" onmouseover="showTip(event, 'fs53', 146)" class="rt">Pickler</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, 'fs54', 147)" onmouseover="showTip(event, 'fs54', 147)" class="id">shape</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs42', 148)" onmouseover="showTip(event, 'fs42', 148)" class="id">getShape</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span>
    <span onmouseout="hideTip(event, 'fs54', 149)" onmouseover="showTip(event, 'fs54', 149)" class="fn">shape</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 150)" onmouseover="showTip(event, 'fs18', 150)" class="id">Accept</span> <span onmouseout="hideTip(event, 'fs55', 151)" onmouseover="showTip(event, 'fs55', 151)" class="id">factory</span> <span class="o">:?&gt;</span> <span onmouseout="hideTip(event, 'fs53', 152)" onmouseover="showTip(event, 'fs53', 152)" class="rt">Pickler</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span>
            
<span class="k">and</span> <span onmouseout="hideTip(event, 'fs55', 153)" onmouseover="showTip(event, 'fs55', 153)" class="id">factory</span> <span class="pn">:</span> <span onmouseout="hideTip(event, 'fs28', 154)" onmouseover="showTip(event, 'fs28', 154)" class="if">ITypeShapeVisitor</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs53', 155)" onmouseover="showTip(event, 'fs53', 155)" class="rt">Pickler</span><span class="pn">&gt;</span> <span class="o">=</span>
    <span class="pn">{</span>
        <span class="k">new</span> <span onmouseout="hideTip(event, 'fs28', 156)" onmouseover="showTip(event, 'fs28', 156)" class="if">ITypeShapeVisitor</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs53', 157)" onmouseover="showTip(event, 'fs53', 157)" class="rt">Pickler</span><span class="pn">&gt;</span> <span class="k">with</span>
            <span class="k">member</span> <span class="id">__</span><span class="pn">.</span><span class="fn">VisitInt</span> <span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs53', 158)" onmouseover="showTip(event, 'fs53', 158)" class="m">Pickler</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs56', 159)" onmouseover="showTip(event, 'fs56', 159)" class="id">int</span> <span class="o">:&gt;</span> <span onmouseout="hideTip(event, 'fs53', 160)" onmouseover="showTip(event, 'fs53', 160)" class="rt">Pickler</span>
            <span class="k">member</span> <span onmouseout="hideTip(event, 'fs57', 161)" onmouseover="showTip(event, 'fs57', 161)" class="id">__</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 162)" onmouseover="showTip(event, 'fs18', 162)" class="fn">VisitString</span> <span class="pn">(</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs53', 163)" onmouseover="showTip(event, 'fs53', 163)" class="m">Pickler</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs58', 164)" onmouseover="showTip(event, 'fs58', 164)" class="id">string</span> <span class="o">:&gt;</span> <span onmouseout="hideTip(event, 'fs53', 165)" onmouseover="showTip(event, 'fs53', 165)" class="rt">Pickler</span>
            <span class="k">member</span> <span onmouseout="hideTip(event, 'fs57', 166)" onmouseover="showTip(event, 'fs57', 166)" class="id">__</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 167)" onmouseover="showTip(event, 'fs18', 167)" class="fn">VisitList</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, 'fs15', 168)" onmouseover="showTip(event, 'fs15', 168)" class="id">tp</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 169)" onmouseover="showTip(event, 'fs52', 169)" class="fn">generate</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fs53', 170)" onmouseover="showTip(event, 'fs53', 170)" class="m">Pickler</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs59', 171)" onmouseover="showTip(event, 'fs59', 171)" class="id">list</span> <span onmouseout="hideTip(event, 'fs15', 172)" onmouseover="showTip(event, 'fs15', 172)" class="id">tp</span> <span class="o">:&gt;</span> <span onmouseout="hideTip(event, 'fs53', 173)" onmouseover="showTip(event, 'fs53', 173)" class="rt">Pickler</span>

            <span class="k">member</span> <span onmouseout="hideTip(event, 'fs57', 174)" onmouseover="showTip(event, 'fs57', 174)" class="id">__</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 175)" onmouseover="showTip(event, 'fs18', 175)" class="fn">VisitTuple</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">,</span> <span class="ta">&#39;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, 'fs15', 176)" onmouseover="showTip(event, 'fs15', 176)" class="id">tp</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 177)" onmouseover="showTip(event, 'fs52', 177)" class="fn">generate</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, 'fs60', 178)" onmouseover="showTip(event, 'fs60', 178)" class="id">sp</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 179)" onmouseover="showTip(event, 'fs52', 179)" class="fn">generate</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">S</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>
                <span onmouseout="hideTip(event, 'fs53', 180)" onmouseover="showTip(event, 'fs53', 180)" class="m">Pickler</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs61', 181)" onmouseover="showTip(event, 'fs61', 181)" class="id">pair</span> <span onmouseout="hideTip(event, 'fs15', 182)" onmouseover="showTip(event, 'fs15', 182)" class="id">tp</span> <span onmouseout="hideTip(event, 'fs60', 183)" onmouseover="showTip(event, 'fs60', 183)" class="id">sp</span> <span class="o">:&gt;</span> <span onmouseout="hideTip(event, 'fs53', 184)" onmouseover="showTip(event, 'fs53', 184)" class="rt">Pickler</span>

            <span class="k">member</span> <span onmouseout="hideTip(event, 'fs57', 185)" onmouseover="showTip(event, 'fs57', 185)" class="id">__</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs18', 186)" onmouseover="showTip(event, 'fs18', 186)" class="fn">VisitSet</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span> <span class="k">when</span> <span class="ta">&#39;</span><span class="id">T</span> <span class="pn">:</span> <span class="id">comparison</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, 'fs62', 187)" onmouseover="showTip(event, 'fs62', 187)" class="id">tp</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 188)" onmouseover="showTip(event, 'fs52', 188)" class="fn">generate</span><span class="pn">&lt;</span><span class="ta">&#39;</span><span class="id">T</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span> <span class="k">in</span> <span onmouseout="hideTip(event, 'fs53', 189)" onmouseover="showTip(event, 'fs53', 189)" class="m">Pickler</span><span class="pn">.</span><span onmouseout="hideTip(event, 'fs63', 190)" onmouseover="showTip(event, 'fs63', 190)" class="id">set</span> <span onmouseout="hideTip(event, 'fs62', 191)" onmouseover="showTip(event, 'fs62', 191)" class="id">tp</span> <span class="o">:&gt;</span> <span onmouseout="hideTip(event, 'fs53', 192)" onmouseover="showTip(event, 'fs53', 192)" class="rt">Pickler</span>
    <span class="pn">}</span>
</code></pre></td>
</tr>
</table>
<p>The <code>generate</code> function can now be used for auto-generating derivative picklers:</p>
<table class="pre"><tr><td class="lines"><pre class="fssnip"><span class="l">1: </span>
<span class="l">2: </span>
<span class="l">3: </span>
</pre></td>
<td class="snippet"><pre class="fssnip highlighted"><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, 'fs64', 193)" onmouseover="showTip(event, 'fs64', 193)" class="id">p1</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 194)" onmouseover="showTip(event, 'fs52', 194)" class="fn">generate</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs14', 195)" onmouseover="showTip(event, 'fs14', 195)" class="vt">int</span> <span class="pn">*</span> <span onmouseout="hideTip(event, 'fs32', 196)" onmouseover="showTip(event, 'fs32', 196)" class="rt">string</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs65', 197)" onmouseover="showTip(event, 'fs65', 197)" class="id">p2</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 198)" onmouseover="showTip(event, 'fs52', 198)" class="fn">generate</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs14', 199)" onmouseover="showTip(event, 'fs14', 199)" class="vt">int</span> <span class="pn">*</span> <span onmouseout="hideTip(event, 'fs32', 200)" onmouseover="showTip(event, 'fs32', 200)" class="rt">string</span> <span onmouseout="hideTip(event, 'fs37', 201)" onmouseover="showTip(event, 'fs37', 201)" class="rt">list</span> <span onmouseout="hideTip(event, 'fs37', 202)" onmouseover="showTip(event, 'fs37', 202)" class="rt">list</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span> 
<span class="k">let</span> <span onmouseout="hideTip(event, 'fs66', 203)" onmouseover="showTip(event, 'fs66', 203)" class="id">p3</span> <span class="o">=</span> <span onmouseout="hideTip(event, 'fs52', 204)" onmouseover="showTip(event, 'fs52', 204)" class="fn">generate</span><span class="pn">&lt;</span><span class="pn">(</span><span onmouseout="hideTip(event, 'fs14', 205)" onmouseover="showTip(event, 'fs14', 205)" class="vt">int</span> <span class="pn">*</span> <span onmouseout="hideTip(event, 'fs40', 206)" onmouseover="showTip(event, 'fs40', 206)" class="rt">Set</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs32', 207)" onmouseover="showTip(event, 'fs32', 207)" class="rt">string</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="pn">*</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs32', 208)" onmouseover="showTip(event, 'fs32', 208)" class="rt">string</span> <span class="pn">*</span> <span class="pn">(</span><span onmouseout="hideTip(event, 'fs14', 209)" onmouseover="showTip(event, 'fs14', 209)" class="vt">int</span> <span class="pn">*</span> <span onmouseout="hideTip(event, 'fs40', 210)" onmouseover="showTip(event, 'fs40', 210)" class="rt">Set</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, 'fs32', 211)" onmouseover="showTip(event, 'fs32', 211)" class="rt">string</span><span class="pn">&gt;</span><span class="pn">)</span> <span onmouseout="hideTip(event, 'fs37', 212)" onmouseover="showTip(event, 'fs37', 212)" class="rt">list</span><span class="pn">)</span><span class="pn">&gt;</span> <span class="pn">(</span><span class="pn">)</span>
</code></pre></td>
</tr>
</table>

<div class="tip" id="fs1">namespace System</div>
<div class="tip" id="fs2">namespace MBrace</div>
<div class="tip" id="fs3">namespace MBrace.FsPickler</div>
<div class="tip" id="fs4">namespace MBrace.FsPickler.Combinators</div>
<div class="tip" id="fs5">type SomeType</div>
<div class="tip" id="fs6">Multiple items<br />module Pickler<br /><br />from MBrace.FsPickler.Combinators<br /><br />--------------------<br />type Pickler =<br />&#160;&#160;private new : Type -&gt; Pickler<br />&#160;&#160;abstract member private Cast : unit -&gt; Pickler&lt;&#39;S&gt;<br />&#160;&#160;abstract member private Unpack : IPicklerUnpacker&lt;&#39;U&gt; -&gt; &#39;U<br />&#160;&#160;abstract member private UntypedAccept : state:VisitState -&gt; value:obj -&gt; unit<br />&#160;&#160;abstract member private UntypedClone : state:CloneState -&gt; value:obj -&gt; obj<br />&#160;&#160;abstract member private UntypedRead : state:ReadState -&gt; tag:string -&gt; obj<br />&#160;&#160;abstract member private UntypedWrite : state:WriteState -&gt; tag:string -&gt; value:obj -&gt; unit<br />&#160;&#160;abstract member ImplementationType : Type<br />&#160;&#160;abstract member IsCacheByRef : bool<br />&#160;&#160;abstract member IsCloneableOnly : bool<br />&#160;&#160;...<br /><br />--------------------<br />type Pickler&lt;&#39;T&gt; =<br />&#160;&#160;{ Write: WriteState -&gt; &#39;T -&gt; unit<br />&#160;&#160;&#160;&#160;Read: ReadState -&gt; &#39;T }</div>
<div class="tip" id="fs7">Pickler.Write: WriteState -&gt; &#39;T -&gt; unit</div>
<div class="tip" id="fs8">type WriteState =<br />&#160;&#160;private new : formatter:IPickleFormatWriter * resolver:IPicklerResolver * reflectionCache:ReflectionCache * isHashComputation:bool * disableSubtypeResolution:bool * ?streamingContext:StreamingContext * ?sifter:IObjectSifter -&gt; WriteState<br />&#160;&#160;member private GetObjectId : obj:obj * firstTime:byref&lt;bool&gt; -&gt; int64<br />&#160;&#160;member private Reset : unit -&gt; unit<br />&#160;&#160;member private CyclicObjectSet : HashSet&lt;int64&gt;<br />&#160;&#160;member DisableSubtypeResolution : bool<br />&#160;&#160;member private Formatter : IPickleFormatWriter<br />&#160;&#160;member IsHashComputation : bool<br />&#160;&#160;member private ObjectCount : int64<br />&#160;&#160;member private ObjectStack : Stack&lt;int64&gt;<br />&#160;&#160;member private PicklerResolver : IPicklerResolver<br />&#160;&#160;...</div>
<div class="tip" id="fs9">type unit = Unit</div>
<div class="tip" id="fs10">Pickler.Read: ReadState -&gt; &#39;T</div>
<div class="tip" id="fs11">type ReadState =<br />&#160;&#160;private new : formatter:IPickleFormatReader * resolver:IPicklerResolver * reflectionCache:ReflectionCache * disableSubtypeResolution:bool * disableAssemblyLoading:bool * ?streamingContext:StreamingContext * ?sifted:(int64 * obj) [] -&gt; ReadState<br />&#160;&#160;member private EarlyRegisterArray : array:Array -&gt; unit<br />&#160;&#160;member private NextObjectId : unit -&gt; int64<br />&#160;&#160;member private Reset : unit -&gt; unit<br />&#160;&#160;member DisableAssemblyLoading : bool<br />&#160;&#160;member DisableSubtypeResolution : bool<br />&#160;&#160;member private Formatter : IPickleFormatReader<br />&#160;&#160;member private IsUnSifting : bool<br />&#160;&#160;member private ObjectCache : Dictionary&lt;int64,obj&gt;<br />&#160;&#160;member private ObjectCount : int64<br />&#160;&#160;...</div>
<div class="tip" id="fs12">val mkArrayPickler : ip:Pickler&lt;int&gt; -&gt; tp:Pickler&lt;&#39;T&gt; -&gt; Pickler&lt;&#39;T []&gt;</div>
<div class="tip" id="fs13">val ip : Pickler&lt;int&gt;</div>
<div class="tip" id="fs14">Multiple items<br />val int : value:&#39;T -&gt; int (requires member op_Explicit)<br /><br />--------------------<br />type int = int32<br /><br />--------------------<br />type int&lt;&#39;Measure&gt; = int</div>
<div class="tip" id="fs15">val tp : Pickler&lt;&#39;T&gt;</div>
<div class="tip" id="fs16">val s : WriteState</div>
<div class="tip" id="fs17">val a : &#39;T []</div>
<div class="tip" id="fs18"></div>
<div class="tip" id="fs19">type Array =<br />&#160;&#160;member Clone : unit -&gt; obj<br />&#160;&#160;member CopyTo : array:Array * index:int -&gt; unit + 1 overload<br />&#160;&#160;member GetEnumerator : unit -&gt; IEnumerator<br />&#160;&#160;member GetLength : dimension:int -&gt; int<br />&#160;&#160;member GetLongLength : dimension:int -&gt; int64<br />&#160;&#160;member GetLowerBound : dimension:int -&gt; int<br />&#160;&#160;member GetUpperBound : dimension:int -&gt; int<br />&#160;&#160;member GetValue : [&lt;ParamArray&gt;] indices:int[] -&gt; obj + 7 overloads<br />&#160;&#160;member Initialize : unit -&gt; unit<br />&#160;&#160;member IsFixedSize : bool<br />&#160;&#160;...</div>
<div class="tip" id="fs20">val iter : action:(&#39;T -&gt; unit) -&gt; array:&#39;T [] -&gt; unit</div>
<div class="tip" id="fs21">val s : ReadState</div>
<div class="tip" id="fs22">val l : int</div>
<div class="tip" id="fs23">val init : count:int -&gt; initializer:(int -&gt; &#39;T) -&gt; &#39;T []</div>
<div class="tip" id="fs24">type FsPickler =<br />&#160;&#160;private new : unit -&gt; FsPickler<br />&#160;&#160;static member Clone : value:&#39;T * ?pickler:Pickler&lt;&#39;T&gt; * ?streamingContext:StreamingContext -&gt; &#39;T<br />&#160;&#160;static member ComputeHash : value:&#39;T * ?hashFactory:IHashStreamFactory -&gt; HashResult<br />&#160;&#160;static member ComputeSize : value:&#39;T * ?pickler:Pickler&lt;&#39;T&gt; -&gt; int64<br />&#160;&#160;static member CreateBinarySerializer : ?forceLittleEndian:bool * ?typeConverter:ITypeNameConverter * ?picklerResolver:IPicklerResolver -&gt; BinarySerializer<br />&#160;&#160;static member CreateObjectSizeCounter : ?encoding:Encoding * ?resetInterval:int64 -&gt; ObjectSizeCounter<br />&#160;&#160;static member CreateXmlSerializer : ?typeConverter:ITypeNameConverter * ?indent:bool * ?picklerResolver:IPicklerResolver -&gt; XmlSerializer<br />&#160;&#160;static member EnsureSerializable : graph:&#39;T * ?failOnCloneableOnlyTypes:bool -&gt; unit<br />&#160;&#160;static member GatherObjectsInGraph : graph:obj -&gt; obj []<br />&#160;&#160;static member GatherTypesInObjectGraph : graph:obj -&gt; Type []<br />&#160;&#160;...</div>
<div class="tip" id="fs25">static member FsPickler.IsSerializableType : unit -&gt; bool<br />static member FsPickler.IsSerializableType : t:Type -&gt; bool</div>
<div class="tip" id="fs26">Multiple items<br />type AbstractClassAttribute =<br />&#160;&#160;inherit Attribute<br />&#160;&#160;new : unit -&gt; AbstractClassAttribute<br /><br />--------------------<br />new : unit -&gt; AbstractClassAttribute</div>
<div class="tip" id="fs27">Multiple items<br />type TypeShape&lt;&#39;T&gt; =<br />&#160;&#160;new : unit -&gt; TypeShape&lt;&#39;T&gt;<br />&#160;&#160;abstract member Accept : ITypeShapeVisitor&lt;&#39;R&gt; -&gt; &#39;R<br /><br />--------------------<br />new : unit -&gt; TypeShape&lt;&#39;T&gt;</div>
<div class="tip" id="fs28">type ITypeShapeVisitor&lt;&#39;R&gt; =<br />&#160;&#160;interface<br />&#160;&#160;&#160;&#160;abstract member VisitInt : unit -&gt; &#39;R<br />&#160;&#160;&#160;&#160;abstract member VisitList : unit -&gt; &#39;R<br />&#160;&#160;&#160;&#160;abstract member VisitSet : unit -&gt; &#39;R<br />&#160;&#160;&#160;&#160;abstract member VisitString : unit -&gt; &#39;R<br />&#160;&#160;&#160;&#160;abstract member VisitTuple : unit -&gt; &#39;R<br />&#160;&#160;end</div>
<div class="tip" id="fs29">Multiple items<br />type ShapeInt =<br />&#160;&#160;inherit TypeShape&lt;int&gt;<br />&#160;&#160;new : unit -&gt; ShapeInt<br />&#160;&#160;override Accept : v:ITypeShapeVisitor&lt;&#39;e&gt; -&gt; &#39;e<br /><br />--------------------<br />new : unit -&gt; ShapeInt</div>
<div class="tip" id="fs30">val v : ITypeShapeVisitor&lt;&#39;e&gt;</div>
<div class="tip" id="fs31">Multiple items<br />type ShapeString =<br />&#160;&#160;inherit TypeShape&lt;string&gt;<br />&#160;&#160;new : unit -&gt; ShapeString<br />&#160;&#160;override Accept : v:ITypeShapeVisitor&lt;&#39;d&gt; -&gt; &#39;d<br /><br />--------------------<br />new : unit -&gt; ShapeString</div>
<div class="tip" id="fs32">Multiple items<br />val string : value:&#39;T -&gt; string<br /><br />--------------------<br />type string = String</div>
<div class="tip" id="fs33">val v : ITypeShapeVisitor&lt;&#39;d&gt;</div>
<div class="tip" id="fs34">Multiple items<br />type ShapeTuple&lt;&#39;T,&#39;S&gt; =<br />&#160;&#160;inherit TypeShape&lt;&#39;T * &#39;S&gt;<br />&#160;&#160;new : unit -&gt; ShapeTuple&lt;&#39;T,&#39;S&gt;<br />&#160;&#160;override Accept : v:ITypeShapeVisitor&lt;&#39;c&gt; -&gt; &#39;c<br /><br />--------------------<br />new : unit -&gt; ShapeTuple&lt;&#39;T,&#39;S&gt;</div>
<div class="tip" id="fs35">val v : ITypeShapeVisitor&lt;&#39;c&gt;</div>
<div class="tip" id="fs36">Multiple items<br />type ShapeList&lt;&#39;T&gt; =<br />&#160;&#160;inherit TypeShape&lt;&#39;T list&gt;<br />&#160;&#160;new : unit -&gt; ShapeList&lt;&#39;T&gt;<br />&#160;&#160;override Accept : v:ITypeShapeVisitor&lt;&#39;b&gt; -&gt; &#39;b<br /><br />--------------------<br />new : unit -&gt; ShapeList&lt;&#39;T&gt;</div>
<div class="tip" id="fs37">type &#39;T list = List&lt;&#39;T&gt;</div>
<div class="tip" id="fs38">val v : ITypeShapeVisitor&lt;&#39;b&gt;</div>
<div class="tip" id="fs39">Multiple items<br />type ShapeSet&lt;&#39;T (requires comparison)&gt; =<br />&#160;&#160;inherit TypeShape&lt;Set&lt;&#39;T&gt;&gt;<br />&#160;&#160;new : unit -&gt; ShapeSet&lt;&#39;T&gt;<br />&#160;&#160;override Accept : v:ITypeShapeVisitor&lt;&#39;a&gt; -&gt; &#39;a<br /><br />--------------------<br />new : unit -&gt; ShapeSet&lt;&#39;T&gt;</div>
<div class="tip" id="fs40">Multiple items<br />module Set<br /><br />from Microsoft.FSharp.Collections<br /><br />--------------------<br />type Set&lt;&#39;T (requires comparison)&gt; =<br />&#160;&#160;interface IReadOnlyCollection&lt;&#39;T&gt;<br />&#160;&#160;interface IComparable<br />&#160;&#160;interface IEnumerable<br />&#160;&#160;interface IEnumerable&lt;&#39;T&gt;<br />&#160;&#160;interface ICollection&lt;&#39;T&gt;<br />&#160;&#160;new : elements:seq&lt;&#39;T&gt; -&gt; Set&lt;&#39;T&gt;<br />&#160;&#160;member Add : value:&#39;T -&gt; Set&lt;&#39;T&gt;<br />&#160;&#160;member Contains : value:&#39;T -&gt; bool<br />&#160;&#160;override Equals : obj -&gt; bool<br />&#160;&#160;member IsProperSubsetOf : otherSet:Set&lt;&#39;T&gt; -&gt; bool<br />&#160;&#160;...<br /><br />--------------------<br />new : elements:seq&lt;&#39;T&gt; -&gt; Set&lt;&#39;T&gt;</div>
<div class="tip" id="fs41">val v : ITypeShapeVisitor&lt;&#39;a&gt;</div>
<div class="tip" id="fs42">val getShape&lt;&#39;T&gt; : TypeShape&lt;&#39;T&gt;</div>
<div class="tip" id="fs43">val typeof&lt;&#39;T&gt; : Type</div>
<div class="tip" id="fs44">type obj = Object</div>
<div class="tip" id="fs45">val gt : Type</div>
<div class="tip" id="fs46">val tparams : Type []</div>
<div class="tip" id="fs47">val typedefof&lt;&#39;T&gt; : Type</div>
<div class="tip" id="fs48">val st : Type</div>
<div class="tip" id="fs49">type Activator =<br />&#160;&#160;static member CreateInstance&lt;&#39;T&gt; : unit -&gt; &#39;T + 9 overloads<br />&#160;&#160;static member CreateInstanceFrom : assemblyFile:string * typeName:string -&gt; ObjectHandle + 2 overloads</div>
<div class="tip" id="fs50">Activator.CreateInstance&lt;&#39;T&gt;() : &#39;T<br />Activator.CreateInstance(type: Type) : obj<br />Activator.CreateInstance(type: Type, nonPublic: bool) : obj<br />Activator.CreateInstance(assemblyName: string, typeName: string) : Runtime.Remoting.ObjectHandle<br />Activator.CreateInstance(type: Type, [&lt;ParamArray&gt;] args: obj []) : obj<br />Activator.CreateInstance(assemblyName: string, typeName: string, activationAttributes: obj []) : Runtime.Remoting.ObjectHandle<br />Activator.CreateInstance(type: Type, args: obj [], activationAttributes: obj []) : obj<br />Activator.CreateInstance(type: Type, bindingAttr: Reflection.BindingFlags, binder: Reflection.Binder, args: obj [], culture: Globalization.CultureInfo) : obj<br />Activator.CreateInstance(type: Type, bindingAttr: Reflection.BindingFlags, binder: Reflection.Binder, args: obj [], culture: Globalization.CultureInfo, activationAttributes: obj []) : obj<br />Activator.CreateInstance(assemblyName: string, typeName: string, ignoreCase: bool, bindingAttr: Reflection.BindingFlags, binder: Reflection.Binder, args: obj [], culture: Globalization.CultureInfo, activationAttributes: obj []) : Runtime.Remoting.ObjectHandle</div>
<div class="tip" id="fs51">val failwith : message:string -&gt; &#39;T</div>
<div class="tip" id="fs52">val generate : unit -&gt; Pickler&lt;&#39;T&gt;</div>
<div class="tip" id="fs53">Multiple items<br />module Pickler<br /><br />from MBrace.FsPickler.Combinators<br /><br />--------------------<br />type Pickler =<br />&#160;&#160;private new : Type -&gt; Pickler<br />&#160;&#160;abstract member private Cast : unit -&gt; Pickler&lt;&#39;S&gt;<br />&#160;&#160;abstract member private Unpack : IPicklerUnpacker&lt;&#39;U&gt; -&gt; &#39;U<br />&#160;&#160;abstract member private UntypedAccept : state:VisitState -&gt; value:obj -&gt; unit<br />&#160;&#160;abstract member private UntypedClone : state:CloneState -&gt; value:obj -&gt; obj<br />&#160;&#160;abstract member private UntypedRead : state:ReadState -&gt; tag:string -&gt; obj<br />&#160;&#160;abstract member private UntypedWrite : state:WriteState -&gt; tag:string -&gt; value:obj -&gt; unit<br />&#160;&#160;abstract member ImplementationType : Type<br />&#160;&#160;abstract member IsCacheByRef : bool<br />&#160;&#160;abstract member IsCloneableOnly : bool<br />&#160;&#160;...<br /><br />--------------------<br />type Pickler&lt;&#39;T&gt; =<br />&#160;&#160;inherit Pickler<br />&#160;&#160;private new : unit -&gt; Pickler&lt;&#39;T&gt;<br />&#160;&#160;abstract member Accept : state:VisitState -&gt; value:&#39;T -&gt; unit<br />&#160;&#160;abstract member Clone : state:CloneState -&gt; value:&#39;T -&gt; &#39;T<br />&#160;&#160;abstract member Read : state:ReadState -&gt; tag:string -&gt; &#39;T<br />&#160;&#160;abstract member Write : state:WriteState -&gt; tag:string -&gt; value:&#39;T -&gt; unit<br />&#160;&#160;override private Unpack : IPicklerUnpacker&lt;&#39;R&gt; -&gt; &#39;R<br />&#160;&#160;override private UntypedAccept : state:VisitState -&gt; value:obj -&gt; unit<br />&#160;&#160;override private UntypedClone : state:CloneState -&gt; obj -&gt; obj<br />&#160;&#160;override private UntypedRead : state:ReadState -&gt; tag:string -&gt; obj<br />&#160;&#160;...</div>
<div class="tip" id="fs54">val shape : TypeShape&lt;&#39;T&gt;</div>
<div class="tip" id="fs55">val factory : ITypeShapeVisitor&lt;Pickler&gt;</div>
<div class="tip" id="fs56">val int : Pickler&lt;int&gt;</div>
<div class="tip" id="fs57">val __ : ITypeShapeVisitor&lt;Pickler&gt;</div>
<div class="tip" id="fs58">val string : Pickler&lt;string&gt;</div>
<div class="tip" id="fs59">val list : f:Pickler&lt;&#39;T&gt; -&gt; Pickler&lt;&#39;T list&gt;</div>
<div class="tip" id="fs60">val sp : Pickler&lt;&#39;S&gt;</div>
<div class="tip" id="fs61">val pair : f:Pickler&lt;&#39;a&gt; -&gt; g:Pickler&lt;&#39;b&gt; -&gt; Pickler&lt;&#39;a * &#39;b&gt;</div>
<div class="tip" id="fs62">val tp : Pickler&lt;&#39;T&gt; (requires comparison)</div>
<div class="tip" id="fs63">val set : f:Pickler&lt;&#39;T&gt; -&gt; Pickler&lt;Set&lt;&#39;T&gt;&gt; (requires comparison)</div>
<div class="tip" id="fs64">val p1 : Pickler&lt;int * string&gt;</div>
<div class="tip" id="fs65">val p2 : Pickler&lt;int * string list list&gt;</div>
<div class="tip" id="fs66">val p3 : Pickler&lt;(int * Set&lt;string&gt;) * (string * (int * Set&lt;string&gt;) list)&gt;</div>

        </div>
        <div class="span3">
          <a target="_blank" href="http://mbrace.io/">
      <img src="/FsPickler/img/mbrace.png" alt="F# Project" style="width:150px;margin:10px" /> 
      </a>
          <ul class="nav nav-list" id="menu" style="margin-top: 20px;">
            <li class="nav-header">FsPickler</li>
            <li><a href="/FsPickler/index.html">Home page</a></li>
            <li class="divider"></li>
            <li><a href="http://www.nuget.org/packages/FsPickler">Get Library via NuGet</a></li>
            <li><a href="http://github.com/mbraceproject/FsPickler">Source Code on GitHub</a></li>
            <li><a href="http://github.com/mbraceproject/FsPickler/blob/master/License.md">License</a></li>
            <li><a href="http://github.com/mbraceproject/FsPickler/blob/master/RELEASE_NOTES.md">Release Notes</a></li>

            <li class="nav-header">Documentation</li>
            <li><a href="/FsPickler/tutorial.html">Tutorial</a></li>
            <li><a href="/FsPickler/overview.html">Technical Overview</a></li>
            <li><a href="https://github.com/mbraceproject/FsPickler/wiki/.NET-Core-Benchmarks">Performance</a></li>
            <li><a href="/FsPickler/reference/index.html">API Reference</a></li>
          </ul>
        </div>
      </div>
    </div>
    <a href="http://github.com/mbraceproject/FsPickler"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png" alt="Fork me on GitHub"/></a>
  </body>
  </html>
